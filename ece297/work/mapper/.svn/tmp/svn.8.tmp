/*
 *This program draws the graphics of a city map and allows the user to interact with 
 * it by highlighting objects when clicked and provides geographical information.
 */
//(135,206,250) LAKE COLOR
//	rgb(144,238,144) PARK COLOR
//	darkgreen	#006400	rgb(0,100,0)
//background rgb(240,240,240)
//	rgb(255,228,181)

#include "StreetsDatabaseAPI.h"
#include "LatLon.h"
#include "graphics.h"
#include "m1.h"
#include "m2.h"
#include "m2_2.h"
#include <algorithm>
#include <vector>
#include <cmath>  
#include <boost/geometry.hpp>
#include <boost/geometry/geometries/register/point.hpp>
#include <boost/geometry/index/rtree.hpp>
#include <readline/readline.h>
#include <readline/history.h>
#include "IntersectionNode.h"
#include "Edges.h"
//#include "Graph.h"

namespace bg = boost::geometry;
namespace bgi = boost::geometry::index;

//R-Trees           
typedef std::pair<RTreeLatLon, unsigned> feature_rtree_pair;
bgi::rtree<feature_rtree_pair, bgi::quadratic<16>> featureRTree;

unsigned feature_id_rtree = 0; //for rtree
double average_latitude;
bool clicked_subway = false;
bool clicked_poi = false;
bool clicked_get_directions = false;   //arfa added
bool clicked_legend = false;  
bool clicked_help = false;  
bool clicked_clear = false;  
float overall_area;
bool has_clicked = false;
bool clicked_intersection=false;
bool feat = true;
double maximum_latitude = 1000;
double minimum_latitude = 0;
double maximum_longitude = 1000;
double minimum_longitude = 0;
float const width = 0.0001;
float const height = 0.0001;
bool find_intersections = false;
bool found_start_end_intersections=false;    //arfa added
LatLon clicked_on;  
 //determine which one to highlight based on smallest speed
    bool highlight_int=false;
    bool highlight_poi=false;
    bool highlight_feature=false;
    int count_num_int_clicked=0;
    unsigned first_int=-1;
    unsigned second_int=-1;
double maximum_speed;
///////////FIX//////////////
//Graph map_graph;

//All the data structures
//Stores intersection information for each intersection ids
std::vector<intersection_data> intersections;
//Stores point of interest information for each poi ids
std::vector<poi_data> poi;
//Stores feature information for feature ids
std::vector<feature_data> features;
//Store street information for each street segment ids
std::vector<street_data> streets;
//Stores intersection ids of two streets for find
std::vector<unsigned> intersection_ids;      //arfa added
std::vector<unsigned> intersection_start_ids; //arfa added
std::vector<unsigned> intersection_end_ids;//arfa added
std::vector<unsigned> street_ids; //arfa added
//Stores the poi name and poi id
 std::unordered_map<std::string, std::vector<unsigned>> poi_from_name;
 //Store all the available cites
std::vector<std::string> available_city{
    "beijing_china",
            "cairo_egypt",
            "cape-town_south-africa",
            "golden-horseshoe_canada",
            "hamilton_canada",
            "hong-kong_china",
            "iceland",
            "interlaken_switzerland",
            "london_england",
            "moscow_russia",
            "new-delhi_india",
            "new-york_usa",
            "rio-de-jeneiro_brazil",
            "saint-helena",
            "singapore",
            "sydney_australia",
            "tehran_iran",
            "tokyo_japan",
            "toronto_canada",
            "beijing_china"
};


//Loads the new map again when changing the map
bool load_my_map(std::string map_path, std::string map_path_osm){   
    
    //Load the map and related data structures
    bool load_success = load_map(map_path);
    bool load_OSM = loadOSMDatabaseBIN(map_path_osm);
    
    if(!load_success) {
        std::cout << "Failed to load map. Enter again." << map_path << "'\n";
        return false;
    }
    if(!load_OSM){
        std::cout << "Failed to load map. Enter again." << map_path_osm << "'\n";
        return false;
    }

    std::cout << "Successfully loaded map '" << map_path << "'\n";
   
    std::cout << "Successfully loaded map '" << map_path_osm << "'\n";

    return true;
}
//Prints instruction for changing a map
void print_instructions(){
    
    std::cout << "Please enter the command and arguments from the list below." <<
            std::endl;
    std::cout <<"\"load_map 'city_name'\", where city_name is a valid city" << 
            std::endl;
    std::cout << "\"default\" for map of Toronto, Canada" << std::endl;
    std::cout << "\"exit\" for keeping the same map" << std::endl;
    std::cout << "\"city\" for list of available cities" << std::endl;
    std::cout << "\"help\" for repeating these lines" << std::endl;
    return;
}
void change_map(void(*draw_screen) (void)){
    std::string city_map = "";
    std::string command = ";";
    std::string city = "";
    std::string map_path;
    std::string map_path_osm;
    bool valid = false;
    
    print_instructions();
    
    
   //Keep asking user for a valid city input
    while(!valid){
        std::cout << "> ";
        getline(std::cin, city_map);    
        std::stringstream map;
        map << city_map;
    
        map >> command;
        
        //Parse the command
        if(map.fail()){
            std::cout << "Invalid Command. Enter help for list of commands." <<
                    std::endl;
        }
        else if(command== "load_map" ){
            map >> city;
            if(map.fail()){
                std::cout << "Invalid Command. Enter help for more information."
                        << std::endl;
                valid = false;
            }
            else { 
                    if(std::find(available_city.begin(),available_city.end(),city)!=available_city.end()){
                   close_map();
                   closeOSMDatabase();
                   map_path = "/cad2/ece297s/public/maps/" + city + ".streets.bin";
                   map_path_osm = "/cad2/ece297s/public/maps/" + city + ".osm.bin";
                   if(!load_my_map(map_path,map_path_osm))
                       valid = false;
                   else
                       valid = true;
                }
                    else{
                        std::cout<<"The city is not available. Please enter \"city\" "
                                "to get the list of available cities"<<std::endl;
                    }
            }

        }
        else if(command=="city"){
            for(unsigned k=0;k<available_city.size();++k){
                std::cout<<available_city[k]<<std::endl;
            }
        }
        else if(command == "default"){
            close_map();
            closeOSMDatabase();
            map_path = "/cad2/ece297s/public/maps/toronto_canada.streets.bin";
            map_path_osm = "/cad2/ece297s/public/maps/toronto_canada.osm.bin";
            if(!load_my_map(map_path, map_path_osm))
               valid = false;
            else
               valid = true;
            }
        else if (command == "help"){
            print_instructions();
            valid = false;
        }
        else if(command == "exit"){
             return;
        }
        else{
            std::cout << "Invalid Command. Enter help for more information." << 
                    std::endl;
            valid = false;
        }
        
        
    }
    
    //Clean-up the map data and related data structures
    delete_all();
    get_data();
    set_visible_world(
        minimum_longitude * std::cos(average_latitude),
        minimum_latitude,
        maximum_longitude * std::cos(average_latitude),
        maximum_latitude 
    );
    clearscreen();
    draw_screen();
    
    return;
}



//Draws map features on the screen
void draw_screen(){
    clearscreen();//Clears previously drawn
    
    bool view_small_streets = false;
    bool view_intersections = false;
    bool view_buildings = false;
    bool view_small_streets_name = false;
    bool view_large_streets_name = false;
    bool view_highway = false;
    bool view_poi_name = false;
    
    //Constants for area
    const double SMALL_STREET_DIVISOR=16.0;
    const double INTERSECTION_DIVISOR=50.0;
    const double POI_DIVISOR=10000.0;
    const double SMALL_STREET_NAME_DIVISOR=500.0;
    const double LARGE_STREET_NAME_DIVISOR=100.0;
    const double HIGHWAY_DIVISOR=8.0;
    
    
    //Create buffers
    set_drawing_buffer(OFF_SCREEN);
    
    //Get area of current visible screen
    t_bound_box bound_box = get_visible_world();
    auto area = bound_box.area();
    
    //Divide the screens so it shows different features when different visibility
    if(area < overall_area /  SMALL_STREET_DIVISOR){
        view_small_streets = true;
    }
    if(area < overall_area / INTERSECTION_DIVISOR) {
       view_buildings = true;
       view_intersections = true;
    }
    if(area < overall_area / POI_DIVISOR)
        view_poi_name = true;
    
    if(area < overall_area / SMALL_STREET_NAME_DIVISOR)
        view_small_streets_name = true;
    
    if(area < overall_area / LARGE_STREET_NAME_DIVISOR)
        view_large_streets_name = true;
    
    if(area < overall_area / HIGHWAY_DIVISOR)
        view_highway = true;
    
   
   //Add features like parks, lake, rivers, etc in the map
    add_big_features();//Add lake first
    //Add Island next
    add_Islandfeatures();
    //Add all parks in the map
    add_park_features();
    //Add remaining features in the map
    add_small_features(view_buildings);

    
     //Draw the streets based on area
    draw_street(view_small_streets,view_highway );
    
    //Draw intersection and point of intersection
    draw_inter_poi();
    
    //Highlights features the user clicked
    highlight_where_user_clicked();
    
    //Highlight the found intersection
    highlight_found_intersection();
    
    highlight_start_end_intersection();
    //Prints the street name
    print_street_name(view_small_streets_name,view_large_streets_name);
    
    if(clicked_poi && view_poi_name){
        for(unsigned i = 0; i < poi.size(); i++){
            auto x = longitude_to_cartesian(poi[i].position2.lon());
            auto y = latitude_to_cartesian(poi[i].position2.lat());  
            setcolor(BLACK);
            drawtext(x, y, poi[i].name, 100, 100);
        }
    }
      show_clear();
    //Shows subway stations
    show_subway(view_poi_name);
    show_get_directions();
    show_legend();
    show_help();
  
    
    copy_off_screen_buffer_to_screen();
    
    return;
}

//Draw map on graphic
void draw_map(){    
    
    get_data();
    //t_color background=t_color(0,0,0);
    
    init_graphics("Map",t_color(238,238,238));
    
    
    
    set_visible_world(
        minimum_longitude * std::cos(average_latitude),
        minimum_latitude,
        maximum_longitude * std::cos(average_latitude),
        maximum_latitude 
    );
    
    overall_area=get_visible_world().area();
    bool turn_on = true;
    update_message("Welcome to H.A.S. Map! Click on the zoom buttons to zoom, and the arrow keys to navigate. Press the Get Directions Button to get directions between two locations");
    create_button("Window", "Find", find);
    create_button("Find", "Subway", subway);
    create_button("Subway","POI", show_poi);  
    create_button("POI","Change City", change_map);    
    create_button("Change City", "Get Directions", get_directions);     
    create_button("Get Directions","Intersection", show_int);    
    create_button("Intersection","Legend", show_legend); 
    create_button("Legend","Help", show_help); 
     create_button("Help","Clear Screen", show_clear); 
    set_mouse_move_input(turn_on);
    set_keypress_input(turn_on);
    change_button_text("Zoom In", "+");
    change_button_text("Zoom Out", "-");
   
    event_loop(act_on_button_press, nullptr, act_on_key_press, draw_screen);
    clearscreen();
    close_graphics();
    delete_all();
    
    return;
}

//Alternative for pressing a button for subway, poi, find, and change map
void act_on_key_press(char key_pressed, int keysym){
    (void)keysym;
    if (key_pressed == 'c'){
        change_map(*draw_screen);
    }
    if (key_pressed == 'f'){
        find(*draw_screen);
    }
    if (key_pressed == 's'){
        subway(*draw_screen);
    }
    if (key_pressed == 'p'){
        show_poi(*draw_screen);
    }
}
//////////////////////////////////////////////
void get_directions(void(*draw_screen) (void)){
  if(clicked_get_directions == false){
        clicked_get_directions = true;
        std::cout<<"Displaying Directions"<<std::endl;
    }
    else{
        clicked_get_directions = false;
        std::cout<<"Not displaying Directions"<<std::endl;
    }
    draw_screen();
}
void show_legend(void(*draw_screen) (void)){
  if(clicked_legend  == false){
        clicked_legend  = true;
        std::cout<<"Displaying Legend"<<std::endl;
        
    }
    else{
        clicked_legend  = false;
        std::cout<<"Not displaying Legend"<<std::endl;
        }
    draw_screen();
}
void show_help(void(*draw_screen) (void)){
  if(clicked_help == false){
        clicked_help  = true;
        std::cout<<"Displaying Help"<<std::endl;
        
        
    }
    else{
        clicked_help  = false;
        std::cout<<"Not displaying Help"<<std::endl;
        }
    draw_screen();
}
void show_clear(void(*draw_screen) (void)){
  if(clicked_clear == false){
        clicked_clear  = true;
        std::cout<<"Cleared Screen"<<std::endl;
        
        
    }
    else{
        clicked_clear  = false;
        //std::cout<<"Not displaying Help"<<std::endl;
        }
    draw_screen();
}
///////////////////////////////////////////////////////

//Displays subway and tramp stops only
void subway(void(*draw_screen) (void)){
    if(clicked_subway == false){
        clicked_subway = true;
        clicked_intersection=false;
        std::cout<<"Displaying Subway Stations"<<std::endl;
    }
    else{
        clicked_subway = false;
        std::cout<<"Not displaying Subway Stations"<<std::endl;
    }
    
    draw_screen();
    
}

//Displays intersection
void show_int(void(*draw_screen) (void)){
    if(clicked_intersection == false){
        clicked_intersection  = true;
        std::cout<<"Displaying Intersections"<<std::endl;
    }
    else{
        clicked_intersection  = false;
        std::cout<<"Not displaying Intersections"<<std::endl;
    }
    
    draw_screen();
    
}

//Highlights the clicked features, poi and intersections and outputs information
//in command window
void act_on_button_press(float x, float y, t_event_buttonPressed event){
    (void)event;
    
    auto const lon = cartesian_to_longitude(x);
    auto const lat = cartesian_to_latitude(y);
    
    LatLon position(lat, lon);
    
    clicked_on = position;
    has_clicked = true;
    
    find_intersections = false;
    found_start_end_intersections=false; //arfa added
    intersection_ids.clear();
    
    draw_screen();
}

//Shows all the poi name when zoomed in
void show_poi(void (*draw_screen) (void)) {
    if(clicked_poi == false){
        clicked_poi = true;
        std::cout << "Displaying Points of Interest" << std::endl;
    }
    else{
        clicked_poi = false;
        std::cout << "Not Displaying Points of Interest" << std::endl;
    }
    
    draw_screen();
}

//char* intersection_name_generator (const  char* stem_text,int  state)   {
//
//
//static  int  count;
//
//if(state  ==  0)  {
//    
//    count             =             -1;
//}
//
//
//int  text_len   =  strlen(stem_text);
////Search             through             intersection_names             until             we             find             a             match
//while(count    <   (int) intersections.size()-1)   {
//count++;
//std::string name2=intersections[count].name;
//char* n=new char[name2.length()+1];
//std::strcpy(n,name2.c_str());
//if(strncmp(n,  stem_text,  text_len) ==   0)             {
//
//    return strdup(n);
//}
//}
////No             more             matches
//return  NULL;
//}
//
//char** command_completion (const char* stem_text,int start,int end)  {
//
//char** matches  =  NULL;
//
//if(start != 0)             {
//
//
//    matches  =   rl_completion_matches(stem_text,intersection_name_generator);
//
//}
//
//return             matches;
//
//}

//Finds the intersection of two street names
void find(void (*draw_screen) (void)) {
    
    std::cout << "Enter \"input1 & input2 search\" to search." << std::endl;
    std::cout << "Enter \"exit\" to go back to map." << std::endl;
    //std::cout << "Find: ";
    
    //std::vector<std::string> name1;
    //std::vector<std::string> name2;
//    char *user_input;
//    std::string users_streets;
//    //Get input from user
//    //std::string temp;
//    //std::cin >> temp;
//    //bool second_input = false; 
//    rl_bind_key('\t', rl_complete);
//    rl_attempted_completion_function = command_completion;
//    rl_completer_quote_characters = strdup("\"\'");
//    
//    while(user_input=readline("Find: ",user_input)!=NULL){
//        if(strcmp(user_input,"")!=0)
//            add_history(user_input);
//        
//            users_streets=user_input;
//        
//        //Exit if user enters exit
//        if(strcmp(user_input,"exit")==0){
//            return;
//        }
//                
//        free(user_input);
//        user_input=NULL;
//    }
    
//    if(temp=="exit")
//        return;
//    
//    while (temp != "search"){
//        if (temp == "and" && !second_input){
//            second_input = true; 
//        }
//        else if (temp == "and" && second_input){
//            std::cout << "Invalid input, press 'f'!" << std::endl;
//        }
//        else if (!second_input){
//            name1.push_back(temp);
//        }
//        else {
//            name2.push_back(temp);
//        }
//        std::cin >> temp;
//    }
//    
//    std::string input1 = "";
//    std::string input2 = "";
//    
//    //Build street name using user's input
//    for(unsigned i = 0; i < name1.size(); i++) {
//        if (i != name1.size() - 1)
//            input1 += name1[i] + " ";
//        else 
//            input1 += name1[i];
//    }
//    std::cout << input1 << std::endl;
//    
//    for(unsigned i = 0; i < name2.size(); i++) {
//        if (i != name2.size() - 1)
//            input2 += name2[i] + " ";
//        else 
//            input2 += name2[i];
//    }
//    std::cout << input2 << std::endl;
//    
//    intersection_ids = find_intersection_ids_from_street_names(
//                           input1, input2);
//    //Find intersection from names
//    if (intersection_ids.size() == 0){
//        std::cout << "Intersections not found! Invalid streets!" << std::endl;
//        return;
//    }
//    
//    else{
//        std::cout << "Intersections: ";
//
//        for(unsigned i = 0; i < intersection_ids.size(); i++){
//            std::cout << getIntersectionName(intersection_ids[i]) << std::endl;
//        }
//    }
//    
//    
//    //Zoom in and highlight the intersection
//    find_intersections = true;
//    auto xcen = longitude_to_cartesian(getIntersectionPosition(intersection_ids[0])
//                                .lon());
//    auto ycen = latitude_to_cartesian(getIntersectionPosition(intersection_ids[0])
//                                .lat());
//    handle_zoom_in(xcen, ycen, draw_screen);
//    t_bound_box bound_box = get_visible_world();
//    auto area = bound_box.area();
//    while(area >= overall_area/10000){
//        handle_zoom_in(xcen, ycen, draw_screen);
//        bound_box = get_visible_world();
//        area = bound_box.area();
//
//    }
    
    
}


//Print street names in command window
void show_street_names(unsigned street_id, unsigned position_id, int size){
    
    
    if (!streets[streets[street_id].streetid].printed && streets[street_id].name 
            != "<unknown>") {
        //One Way streets
        if(streets[street_id].oneway){
            //Create one way street name
            setcolor(BLACK);
            std::string text = "->";

            std::string name = text + streets[street_id].name + text;
            //settextrotation( 0);
            //settextrotation( streets[street_id].angle);
            //setfontsize(size);

//              drawtext(streets[street_id].x_yposition[position_id].x, 
//                        streets[street_id].x_yposition[position_id].y, 
//                          name, 100, 100);
           // t_bound_box bbox = t_bound_box(
              //      streets[street_id].x_yposition[position_id].x, 
             //       streets[street_id].x_yposition[position_id].y , 
             //       streets[street_id].x_yposition[position_id + 1].x , 
             //       streets[street_id].x_yposition[position_id + 1].y);
            //drawtext_in(bbox, name);
            
            float xcen= (streets[street_id].x_yposition[position_id].x+ streets[street_id].x_yposition[position_id + 1].x)/2;
            float ycen= (streets[street_id].x_yposition[position_id].y+ streets[street_id].x_yposition[position_id + 1].y)/2;
            float xmax=streets[street_id].x_yposition[position_id + 1].x;
            float ymax =streets[street_id].x_yposition[position_id + 1].y;
            
             drawtext(xcen, ycen, name,xmax, ymax);

            streets[streets[street_id].streetid].printed = true;
            //settextrotation( 0);
        }
        else{    
            setcolor(BLACK);
            //settextrotation(0);
            settextrotation( streets[street_id].angle);
            setfontsize(size);

            drawtext(streets[street_id].x_yposition[position_id].x, 
                        streets[street_id].x_yposition[position_id].y, 
                          streets[street_id].name, 100, 100);
            t_bound_box bbox = t_bound_box(
                    streets[street_id].x_yposition[position_id].x, 
                    streets[street_id].x_yposition[position_id].y , 
                    streets[street_id].x_yposition[position_id + 1].x, 
                    streets[street_id].x_yposition[position_id + 1].y);
            drawtext_in(bbox, streets[street_id].name);
//            float xcen= (streets[street_id].x_yposition[position_id].x+ streets[street_id].x_yposition[position_id + 1].x)/2;
//            float ycen= (streets[street_id].x_yposition[position_id].y+ streets[street_id].x_yposition[position_id + 1].y)/2;
//            float xmax=streets[street_id].x_yposition[position_id + 1].x;
//            float ymax =streets[street_id].x_yposition[position_id + 1].y;
//            
//             drawtext(xcen, ycen,streets[street_id].name, xmax, ymax );

            streets[streets[street_id].streetid].printed = true;
            //settextrotation( 0);
        }
    }
    return;
}

//Change longitude system to x
float longitude_to_cartesian(double longitude){
    double x = (longitude) * std::cos(average_latitude);
    
    return x;
}

//Change latitude to y
float latitude_to_cartesian(double latitude){
    double y = latitude;
    
    return y;
}

//Change x to longitude
float cartesian_to_longitude(double x){
    double longitude = x / std::cos(average_latitude);
    
    return longitude;
}
//Change y to latitude
float cartesian_to_latitude(double y){
    double latitude = y;
    
    return latitude;
}


//Add big features in the map
void add_big_features(){
    //Draw feature
    for(unsigned k=0;k<features.size();k++){
        if(feat){
            //Allocate x_y points
            features[k].x_ypoints=new t_point[features[k].position3.size()];

            for(unsigned i=0;i<features[k].position3.size();i++){

                t_point point;
                point.x=longitude_to_cartesian(features[k].position3[i].lon());
                point.y=latitude_to_cartesian(features[k].position3[i].lat());
                features[k].x_ypoints[i]=point;

            }
        }
        if(k==features.size()-1)
            feat=false;
        if(features[k].type==Lake){
            //Turquoise
            draw_features(features[k],135,206,250);
            
        }
        
        else if(features[k].type==Shoreline){
            //light blue sky
            draw_features(features[k], 135,206,235);
            
        }
        
    }
    return;
    
}

//Add Island
void add_Islandfeatures(){
    
    for(unsigned k=0;k<features.size();k++){
        if(features[k].type==Island){           
                    //bisque
                    draw_features(features[k], 	219,219,219);
                }
    }
}
//Add all parks in the map
void add_park_features(){
    //Draw feature
    for(unsigned k=0;k<features.size();k++){
        
        //Chose different colors depending on the feature
        if(features[k].type==Park){
           //set color to green
           draw_features(features[k],152,251,152);
           
        }
       
        else if(features[k].type==Greenspace ){

            //darkgreen
            draw_features(features[k], 144,238,144);
        }
            
        else if(features[k].type==Golfcourse){
            
            //lime green
           draw_features(features[k], 144,238,144);
                
            }
        
        
    }
    return;
    
}

//Add remaining features in the map
void add_small_features(bool view_buildings){
    //Draw feature
    for(unsigned k=0;k<features.size();k++){        
       
        if(features[k].type==Beach){
            //set color to yellow
           
            draw_features(features[k], 255,250,205);
          
            
        }
       
        else if(features[k].type==River){
           //blue
            draw_features(features[k],  135,206,250);
            
        }
       
        else if(features[k].type==Building && view_buildings){
            
           //Thistle color
            draw_features(features[k], 	209,209,209);
            
        }
       
        else if(features[k].type==Stream){
            //blue
            draw_features(features[k], 135,206,250);
            //
        }
        
    }
    return;
    
}

//Draw individual streets with different color depending on closed surface or open
void draw_features(feature_data feature, int r,int g, int b){
    float xmax, xmin, ymax, ymin;
    min_max_x_y(feature, xmax, xmin, ymax, ymin, feature.position3.size());
    auto xcen = (xmax + xmin) / 2;
    auto ycen = (ymax + ymin) / 2;
    
    setlinewidth(1);
    setcolor(r,g,b);
    //Draw polygon if closed surface
    if(feature.closed == true){
        fillpoly(feature.x_ypoints, feature.position3.size());
        
        setcolor(1);
        if(feature.name != "<noname>" && feature.name != "<unspecified>")
            drawtext(xcen, ycen, feature.name, xmax - xcen, ymax - ycen);
        
    }
    //Draw lines if not closed surface
    else{
        for(unsigned i = 0;i < feature.position3.size() - 1; ++i){
            drawline(feature.x_ypoints[i].x,feature.x_ypoints[i].y,
                    feature.x_ypoints[i + 1].x,feature.x_ypoints[i + 1].y);
        }
       
        setcolor(1);
         if(feature.name != "<noname>" && feature.name != "<unspecified>")
            drawtext(xcen, ycen, feature.name, xmax - xcen, ymax - ycen);
    }
    return;
}


//find max and min x and y
void min_max_x_y(feature_data feature, float &xmax,float &xmin, float& ymax, float &ymin,unsigned size){
    float x, y;
    
    for(unsigned j = 0; j < size; ++j){
        x = feature.x_ypoints[j].x;
        y = feature.x_ypoints[j].y;
        
        if(x > xmax || j == 0)
            xmax = x;
        if(y > ymax || j == 0)
            ymax = y;
        if(x < xmin || j == 0)
            xmin = x;
        if(y < ymin || j == 0)
            ymin = y;
    }
    return;
}

//Deletes all dynamically allocated object and clears the data structures;
void delete_all(){
    for(unsigned i = 0; i < features.size(); i++){
        delete [] features[i].x_ypoints;
    }
      
    featureRTree.clear();
    
    feature_id_rtree = 0; 
    clicked_subway = false;
    clicked_get_directions=false;
    clicked_legend=false;
    clicked_help=false;
    clicked_clear=false;
    has_clicked = false;
    clicked_intersection=false;
    maximum_latitude = 1000;
    minimum_latitude = 0;
    maximum_longitude = 1000;
    minimum_longitude = 0;
    find_intersections = false;
    found_start_end_intersections=false;
     feat=true;
    intersection_start_ids.clear();
    intersection_end_ids.clear();
    intersections.clear();
    poi.clear();
    features.clear();
    streets.clear();
    intersection_ids.clear();
    
//    map_graph.all_intersections.clear();
    
    
}



//Returns the nearest feature to the given position
unsigned find_closest_feature(LatLon my_position) {
    //Find nearest feature  and store in the vector named closest
    std::vector<feature_rtree_pair> closest;
    featureRTree.query(bgi::nearest(RTreeLatLon(my_position.lat(), 
        my_position.lon()), 1), 
        std::back_inserter(closest));

    //Returns index to nearest feature
    LatLon smallest_distance_position = closest[0].first.latlon;
    unsigned smallest_distance_index = 0; 
    
    for(unsigned k = 0; k < features.size(); k++){
        for(unsigned i = 0; i < features[k].position3.size(); i++){
        //Insert position and index of feature into r-tree
            if (getFeaturePoint(k, i).lat() == smallest_distance_position.lat() 
                    && getFeaturePoint(k, i).lon() == smallest_distance_position.lon()) {
                smallest_distance_index = k;
                break;
            }
        }
    }
    
    return smallest_distance_index;     
}

//Highlights nearest poi, intersection and features when clicked
void highlight_where_user_clicked(){
     //highlight intersection, feature, poi, based on distance from where user clicked
    if(has_clicked == true){
   
    //determine distance from the nearest intersection, poi, feature
    auto const id1 = find_closest_intersection(clicked_on);        
    auto const id2 = find_closest_point_of_interest(clicked_on);
    auto const id3 =find_closest_feature(clicked_on);
    auto intdis=find_distance_between_two_points(clicked_on,intersections[id1].position1);
    auto poidis=find_distance_between_two_points(clicked_on,poi[id2].position2);
    auto featuresdis=find_distance_between_two_points(clicked_on,features[id3].position3[0])-0.1;
    
   
    
    if((featuresdis<poidis)&&(featuresdis<intdis)){
        
        highlight_int=false;
        highlight_poi=false;
        highlight_feature=true;
        count_num_int_clicked=0;
    }
    else if((poidis<intdis)&&(poidis<featuresdis)){   
        highlight_int=false;
        highlight_poi=true;
        highlight_feature=false;
        count_num_int_clicked=0;
    }
        else{
        
        if(highlight_int==true){  //highlight intersection was previously true
        
            count_num_int_clicked=2;
        highlight_int=true;
        highlight_feature=false;
        highlight_poi=false;
        
        }  
        
        
        else{   
        count_num_int_clicked=1;
        highlight_int=true;
        highlight_feature=false;
        highlight_poi=false;
        }
     
    }
        if(highlight_int){
            if((count_num_int_clicked==2)){
                second_int=id1;
            //draw the first int
        auto const x_first=longitude_to_cartesian(intersections[first_int].position1.lon());
        auto const y_first=latitude_to_cartesian(intersections[first_int].position1.lat());
        //Set color to green    
        setcolor(0,100,0);
        fillarc(x_first, y_first,  width/2.0,0,360);          
            //draw the second int
            //draw the nearest intersection
        auto const x2=longitude_to_cartesian(intersections[id1].position1.lon());
        auto const y2=latitude_to_cartesian(intersections[id1].position1.lat());
        //Set color to red        
        setcolor(4);
        fillarc(x2, y2,  width/2.0,0,360);
       // draw_surface(load_png_from_file("libstreetmap/resources/int_pic.png"),x2,y2);
       // copy_off_screen_buffer_to_screen();
    //print the nearest intersection name and poi name
        std::cout << "You have clicked on the intersection: " << intersections[id1].name << "\n";
        std::cout << "Closest point of interest from this intersection is: " << poi[id2].name << "\n";
        auto adj_int=find_adjacent_intersections(id1);
        std::cout<< "Nearby intersections are: "<<std::endl;
         for(unsigned i=0; i<adj_int.size(); i++){
            std::cout<<intersections[adj_int[i]].name<<std::endl;
        }
        std::cout << "If you want to get directions from " << intersections[first_int].name 
                <<" (GREEN) to "<<intersections[second_int].name<<" (RED) click the get directions button"<< "\n";
              
            }
            
            
            else{
                //store as the first intersection
                 first_int=id1;
                 second_int=-1;
                 //draw the nearest intersection
        auto const x2=longitude_to_cartesian(intersections[id1].position1.lon());
        auto const y2=latitude_to_cartesian(intersections[id1].position1.lat());
        //Set color to red        
        setcolor(4);
        fillarc(x2, y2,  width/2.0,0,360);
       // draw_surface(load_png_from_file("libstreetmap/resources/int_pic.png"),x2,y2);
       // copy_off_screen_buffer_to_screen();
    //print the nearest intersection name and poi name
        std::cout << "You have clicked on the intersection: " << intersections[id1].name << "\n";
        std::cout << "Closest point of interest from this intersection is: " << poi[id2].name << "\n";
        auto adj_int=find_adjacent_intersections(id1);
        std::cout<< "Nearby intersections are: "<<std::endl;
        for(unsigned i=0; i<adj_int.size(); i++){
            std::cout<<intersections[adj_int[i]].name<<std::endl;
        }
            }
        }
    else if(highlight_poi){
        //highlight the nearest poi
        auto const x_pos=longitude_to_cartesian(poi[id2].position2.lon());
        auto const y_pos=latitude_to_cartesian(poi[id2].position2.lat());
       //Set color to red
        setcolor(4);
        fillarc(x_pos, y_pos, width/2.0,0,360);
        std::cout << "You have clicked on a point of interest named: " << poi[id2].name << "\n";
        
        }
    if(highlight_feature){
        //highlight the nearest feature
       draw_features(features[id3], 255,0,0);
        
        std::cout << "You have clicked on a feature of interest called: " << features[id3].name << "\n";
        std::cout<< "This is a "<<type_of_feature(id3)<<"\n";      
        }
       
    }

}

//Indicates what type of feature the user clicked
std::string type_of_feature(unsigned k){
    std::string text;
 if(features[k].type==Park){
           //set color to green
     text="Park";
     return text;
           
        }
        else if(features[k].type==Beach){
            //set color to yellow
           text="Beach";
            return text;
          
            
        }
        else if(features[k].type==Lake){
            //Turquoise
             text="Lake";
            return text;
            
        }
        else if(features[k].type==River){
           
            text="River";
            return text;
            
        }
        else if(features[k].type==Island){
          text="Island";
           return text;
        }
        else if(features[k].type==Shoreline){
           text="Shoreline";
           return text;
        }
        else if(features[k].type==Building){
            
            text="Building";
            return text;
            
        }
        else if(features[k].type==Greenspace ){
            text="Greenspace";
            return text;
        }
            
        else if(features[k].type==Golfcourse){
            text="Golfcourse";
            return text;
                
            }
        else if(features[k].type==Stream){
            
            text="Stream";
            return text;
            
        }
    return "Unknown";
}

//Draws street on the map based on speed limit and visible of the screen
void draw_street(bool view_small_streets,bool view_highway ){
    
    const int SLOW_SPEED=50;
    const int HIGH_SPEED=79;
    //Draw streets
    //For Streets
   for(unsigned k = 0; k < streets.size(); ++k){
        streets[streets[k].streetid].printed = false;
    }
    
    for(unsigned k = 0; k < streets.size(); ++k){
        t_point point;
        
        for(unsigned i = 0; i < streets[k].position4.size(); ++i){
            point.x = longitude_to_cartesian(streets[k].position4[i].lon());
            point.y = latitude_to_cartesian(streets[k].position4[i].lat());            
            streets[k].x_yposition.push_back(point); 
            
            if(i > 0 ){
                //Small street
                if(streets[k].speed_limit <= SLOW_SPEED && view_small_streets){
                    /////////////////////////////////////////
                    if(found_start_end_intersections){
                        std::vector<unsigned> ::iterator it;
                        it=find(street_ids.begin(), street_ids.end(), streets[k].streetid);
                        if(it!=street_ids.end()){
                         setlinewidth(6);
                            setcolor(240,128,128);
                            drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                                streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                        }
                        else {
                            setlinewidth(6);
                            setcolor(WHITE);
                            drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                                streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                        
                        }
                    
                    }
                    //////////////////////////////////////////
                    
                    else{   
                    setlinewidth(6);
                    setcolor(WHITE);
                     drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                            streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                }
                }
                //Medium street
                else if(streets[k].speed_limit <= HIGH_SPEED && streets[k].speed_limit > SLOW_SPEED
                        && view_highway){
                     if(found_start_end_intersections){
                        std::vector<unsigned> ::iterator it;
                        it=find(street_ids.begin(), street_ids.end(), streets[k].streetid);
                        if(it!=street_ids.end()){
                         setlinewidth(6.5);
                            setcolor(240,128,128);
                            drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                                streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                        }
                        else {
                            setlinewidth(6.5);
                            setcolor(WHITE);
                            drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                                streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                        
                        }
                    
                    }
                    //////////////////////////////////////////
                    
                    else{   
                    setlinewidth(6);
                    setcolor(WHITE);
                     drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                            streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                }
                
                
                
                
                }
                
                //For highways
                else if (streets[k].speed_limit>HIGH_SPEED && view_highway){
                    setlinewidth(6.5);                   
                    setcolor(255,228,181);

                    drawline(streets[k].x_yposition[i-1].x,streets[k].x_yposition[i-1].y,
                        streets[k].x_yposition[i].x,streets[k].x_yposition[i].y);
                  
                }
            }
        }
    }
    
   return;
}

//Draws intersection and point of intersection on the screen
void draw_inter_poi(){
    
    if((clicked_intersection && !clicked_subway) ||(clicked_subway && clicked_intersection)){
        for(unsigned i = 0; i < intersections.size(); ++i){
            auto const x1 = longitude_to_cartesian(intersections[i].position1.lon());
            auto const y1 = latitude_to_cartesian(intersections[i].position1.lat());
            //Set intersection color to yellow
            setcolor(6);
            fillarc(x1, y1, width/2.0,0,360);

        }
    }
    
    if(!clicked_subway){
        //Get all the point of interests in the map
        for(unsigned j = 0; j < poi.size(); ++j){
            auto const x2 = longitude_to_cartesian(poi[j].position2.lon());
            auto const y2 = latitude_to_cartesian(poi[j].position2.lat());

            //Set point of intersection to orange
            setcolor(5);
            fillarc(x2, y2, width/2.0,0,360);

        }
    }
    return;
}

//Highlights the found intersection
void highlight_found_intersection(){
    
    if (find_intersections) {
        for(unsigned i = 0; i < intersection_ids.size(); i++){
            auto const x = longitude_to_cartesian(getIntersectionPosition(
                            intersection_ids[i]).lon());
            auto const y = latitude_to_cartesian(getIntersectionPosition(
                            intersection_ids[i]).lat());
            
            //Set color to red
            setcolor(4);
            fillarc(x, y, width/2.0,0,360);
        }
       
    }
    return;
}
///////////////////////////////////////////////////////////////////////////////
void highlight_start_end_intersection(){
    auto xcen =0;
    auto ycen =0;
    if (found_start_end_intersections) {
        
        if((intersection_start_ids.size()!= 0) && (intersection_end_ids.size()!=0) ){   
        for(unsigned i = 0; i < intersection_start_ids.size(); i++){
            auto  x = longitude_to_cartesian(getIntersectionPosition(
                            intersection_start_ids[i]).lon());
            auto y = latitude_to_cartesian(getIntersectionPosition(
                            intersection_start_ids[i]).lat());
            
            //Set color to red
            //setcolor(4);
            x=x-0.000101;
            y=y+0.00035;
            draw_surface(load_png_from_file("libstreetmap/resources/green_2.png"),x,y);
            
            //fillarc(x, y, width/2.0,0,360);
        }
        
        
          for(unsigned i = 0; i < intersection_end_ids.size(); i++){
            auto x = longitude_to_cartesian(getIntersectionPosition(
                            intersection_end_ids[i]).lon());
            auto y = latitude_to_cartesian(getIntersectionPosition(
                            intersection_end_ids[i]).lat());
            
            //Set color to red
            //setcolor(BLACK);
            //fillarc(x, y, width/2.0,0,360);
             x=x-0.000101;
            y=y+0.00035;
            draw_surface(load_png_from_file("libstreetmap/resources/red_2.png"),x,y); 
              xcen = longitude_to_cartesian(x);
              ycen = latitude_to_cartesian(y);
        }
        
    }
              
//            handle_zoom_in(xcen, ycen, draw_screen);
//            t_bound_box bound_box = get_visible_world();
//            auto area = bound_box.area();
//            while(area >= overall_area/1000){
//                handle_zoom_in(xcen, ycen, draw_screen);
//                bound_box = get_visible_world();
//                area = bound_box.area();
//            }   
    }
    return;
}
///////////////////////////////////////////////////////////////////////////////
 //Prints the street name
void print_street_name(bool view_small_streets_name,bool view_large_streets_name){
    const int SLOW_SPEED=50;
    const int HIGH_SPEED=79;
    
     //Prints the street name
    if (!clicked_poi) {
        for(unsigned k = 0; k < streets.size(); ++k){
            for(unsigned i = 1; i < streets[k].position4.size(); ++i){
                //Print small streets
                if(streets[k].speed_limit <= SLOW_SPEED && view_small_streets_name){
                    show_street_names(k, i, 8);
                }
                //Print medium streets
                else if(streets[k].speed_limit <= HIGH_SPEED && streets[k].speed_limit > SLOW_SPEED
                        && view_large_streets_name) {
                    show_street_names(k, i, 8);
                }
                //Print highways
                else if (streets[k].speed_limit > HIGH_SPEED && view_large_streets_name){//For highways
                    show_street_names(k, i, 8);

                }
            }
        }
    }
}

//Shows subway stations when the button is clicked
void show_subway(bool view_poi_name){
    
    //If the subway button is clicked
    if(clicked_subway){
       
        for(unsigned m = 0; m < getNumberOfNodes(); ++m){
            //Loop through all the tags
            for(unsigned i = 0; i < getTagCount(getNodeByIndex(m)); ++i){
                
                //Get the key and value and draw if it  is subway or tram or rail
                std::string key,value;
                std::tie(key,value) = getTagPair(getNodeByIndex(m), i);
                if(key == "railway" && (value == "subway_entrance" || value == "tram_stop" || 
                        value == "rail" || value == "monorail"||value=="subway")){
                    auto pos = getNodeByIndex(m)->coords();
                    auto x = longitude_to_cartesian(pos.lon());
                    auto y = latitude_to_cartesian(pos.lat());
                    
                    setcolor(FIREBRICK);
                    fillarc(x, y, width, 0, 360);

                    if (view_poi_name){
                        setcolor(BLACK);
                        drawtext(x, y, value, 100, 100);
                    }
                }
            }
        }
  
    }
    return;
}
/**********************************not finished*******************************/
void show_get_directions(){
    //LOLA ROAD AND DUPLEX AVENUE
    //TRANMER AVENUE AND DUPLEX avenue
    //If the get direction button is clicked
    if(clicked_get_directions){
        if(count_num_int_clicked==2){
        std::cout << "You are getting directions from " << intersections[first_int].name 
                <<" (GREEN) to "<<intersections[second_int].name<<" (RED)"<< "\n";
        intersection_start_ids.clear();
        intersection_end_ids.clear();
        intersection_start_ids.push_back(first_int);
        intersection_end_ids.push_back(second_int);
        clicked_get_directions=false;
        found_start_end_intersections=true;
        std::string street_name_int1="Lola Road";
        
        street_ids=find_street_ids_from_name(street_name_int1);
        if(street_ids.size()==0) std::cout<<"zero length"<<"\n";
        else std::cout<<"not zero length"<<"\n";
        draw_screen();
        }
        
        
        
        else{
    std::cout << "Enter \"input1 and input2 search\" for starting intersection." << std::endl;
    std::cout << "Enter \"exit\" to go back to map." << std::endl;
    std::cout << "Starting intersection: ";
    
    std::vector<std::string> name1;
    std::vector<std::string> name2;
    
    //Get input from user
    std::string temp;
    std::cin >> temp;
    bool second_input = false; 
    
    if(temp=="exit")
        return;
    
    while (temp != "search"){
        if (temp == "and" && !second_input){
            second_input = true; 
        }
        else if (temp == "and" && second_input){
            std::cout << "Invalid input, press 'g'!" << std::endl;
        }
        else if (!second_input){
            name1.push_back(temp);
        }
        else {
            name2.push_back(temp);
        }
        std::cin >> temp;
    }
    
    std::string input1 = "";
    std::string input2 = "";
    
    //Build street name using user's input
    for(unsigned i = 0; i < name1.size(); i++) {
        if (i != name1.size() - 1)
            input1 += name1[i] + " ";
        else 
            input1 += name1[i];
    }
    std::cout << input1 << std::endl;
    
    for(unsigned i = 0; i < name2.size(); i++) {
        if (i != name2.size() - 1)
            input2 += name2[i] + " ";
        else 
            input2 += name2[i];
    }
    std::cout << input2 << std::endl;
    intersection_start_ids.clear();
    intersection_start_ids = find_intersection_ids_from_street_names(
                           input1, input2);
    //Find intersection from names
    if (intersection_start_ids.size() == 0){
        std::cout << "Intersection not found! Invalid streets!" << std::endl;
        return;
    }
    
    else{
        std::cout << " Starting Intersection: ";

        for(unsigned i = 0; i < intersection_start_ids.size(); i++){
            std::cout << getIntersectionName(intersection_start_ids[i]) << std::endl;
        }
     //****************************//   
        std::cout << "Destination intersection: ";
    
    std::vector<std::string> name11;
    std::vector<std::string> name22;
    
    //Get input from user
    std::string temp2;
    std::cin >> temp2;
    bool second_input_2 = false; 
    
    if(temp2=="exit")
        return;
    
    while (temp2 != "search"){
        if (temp2 == "and" && !second_input_2){
            second_input_2 = true; 
        }
        else if (temp2 == "and" && second_input_2){
            std::cout << "Invalid input, press 'g'!" << std::endl;
        }
        else if (!second_input_2){
            name11.push_back(temp2);
        }
        else {
            name22.push_back(temp2);
        }
        std::cin >> temp2;
    }
    
    std::string input11 = "";
    std::string input22 = "";
    
    //Build street name using user's input
    for(unsigned i = 0; i < name11.size(); i++) {
        if (i != name11.size() - 1)
            input11 += name11[i] + " ";
        else 
            input11 += name11[i];
    }
    std::cout << input11 << std::endl;
    
    for(unsigned i = 0; i < name22.size(); i++) {
        if (i != name22.size() - 1)
            input22 += name22[i] + " ";
        else 
            input22 += name22[i];
    }
    std::cout << input22 << std::endl;
    intersection_end_ids.clear();
    intersection_end_ids = find_intersection_ids_from_street_names(
                           input11, input22);
    //Find intersection from names
    if (intersection_end_ids.size() == 0){
        std::cout << "Intersection not found! Invalid streets!" << std::endl;
        return;
    }
    else{
        std::cout << " Destination Intersection: ";

        for(unsigned i = 0; i < intersection_end_ids.size(); i++){
            std::cout << getIntersectionName(intersection_end_ids[i]) << std::endl;
        }
      //*****************************//  
        
        //wants to get new directions, then false
        //when user clicks on get directions again, previous ones disappear CLEAR BUTTON
        //add do while loop for user input
        //add vector containing street segment ids and they highlight
        //add functiton to store start and end destination from user click
        clicked_get_directions=false;
        found_start_end_intersections=true;
        std::string street_name_int1="Lola Road";
        
        street_ids=find_street_ids_from_name(street_name_int1);
        if(street_ids.size()==0) std::cout<<"zero length"<<"\n";
        else std::cout<<"not zero length"<<"\n";

        return;
        
    }
      
    }
    
    }
    }
}
//Shows subway stations when the button is clicked
void show_legend(){
    //If the subway button is clicked
    if(clicked_legend){
//         auto x = longitude_to_cartesian(minimum_longitude);
//            auto y = latitude_to_cartesian(maximum_latitude); 
             t_bound_box box= get_visible_world();
             auto x= box.left();
             auto y=box.top();
                    
                        
             draw_surface(load_png_from_file("libstreetmap/resources/legend_1.png"),x ,y);
       // draw_surface(load_png_from_file("libstreetmap/resources/legend_Arfa_1 (2).png"),0,0);
    }
    return;
}
void show_help(){
    //If the subway button is clicked
    if(clicked_help){
        std::cout<<"The panel on the right can be used to interact with H.A.S Map"<<std::endl;
        std::cout<<"The + and - buttons can be used to zoom in and out "<<std::endl;
        std::cout<<"Click Zoom Fit Button can be used to out completely "<<std::endl;
        std::cout<<"Click the Find Button to find an intersection "<<std::endl;
        std::cout<<"Click the Subway Button to view all the subway entrances and trams "<<std::endl;
        std::cout<<"Click the POI Button to view all the points of interest"<<std::endl;
        std::cout<<"Click the Change City Button to change the city"<<std::endl;
        std::cout<<"Click the Get Directions Button to get directions between two intersections  "<<std::endl;
        std::cout<<"Click the Intersection Button to view all the intersections "<<std::endl;
        std::cout<<"Click the Legend Button to view the legend "<<std::endl;
        std::cout<<"Press Exit to close the map "<<std::endl;
        clicked_help=false;
    }
    return;
}
void show_clear(){
    //If the subway button is clicked
    if(clicked_clear==true){
    intersection_ids.clear();
    clicked_subway = false;
    clicked_get_directions=false;
    clicked_legend=false;
    clicked_help=false;
    clicked_clear=false;
    has_clicked = false;
    clicked_intersection=false;
    find_intersections = false;
    found_start_end_intersections=false;
    intersection_start_ids.clear();
    intersection_end_ids.clear();
    draw_screen();     
       
    }
    return;
}
/*******************************************************************************/

//Gets all the data from API for global vectors
void get_data(){
    
    maximum_latitude = getIntersectionPosition(0).lat();
    minimum_latitude = maximum_latitude;
    maximum_longitude = getIntersectionPosition(0).lon();
    minimum_longitude = maximum_longitude;
    
   
    
    //Get minimum and maximum data for intersections
    //Store intersection data
    intersections.resize(getNumberOfIntersections());
    for(unsigned id = 0; id < getNumberOfIntersections(); ++id){
        intersections[id].position1 = getIntersectionPosition(id);
        intersections[id].name = getIntersectionName(id);
        
        maximum_latitude = std::max(maximum_latitude, 
                intersections[id].position1.lat());
        maximum_longitude = std::max(maximum_longitude, 
                intersections[id].position1.lon());
        
        minimum_latitude = std::min(minimum_latitude, 
                intersections[id].position1.lat());
        minimum_longitude = std::min(minimum_longitude, 
                intersections[id].position1.lon());
        
    }
    
    //Get minimum and maximum data for point of intersections
    //Store poi data
    poi.resize(getNumberOfPointsOfInterest());
    std::vector<unsigned> poi_id_vec;
    for(unsigned id = 0; id < getNumberOfPointsOfInterest(); ++id){
        
        poi[id].position2 = getPointOfInterestPosition(id);
        poi[id].name = getPointOfInterestName(id);
        
        maximum_latitude = std::max(maximum_latitude, 
                poi[id].position2.lat());
        maximum_longitude = std::max(maximum_longitude, 
                poi[id].position2.lon());
        
        minimum_latitude = std::min(minimum_latitude, 
                poi[id].position2.lat());
        minimum_longitude = std::min(minimum_longitude, 
                poi[id].position2.lon());
        
      
        //build an unordered map to find poi from name     
            //If the name already exists add the poi Id in the vector
        auto search = poi_from_name.find( poi[id].name);

        if(search != poi_from_name.end()){
             poi_from_name[poi[id].name].push_back(id);
        }
        else{
            poi_id_vec.push_back(id);
            poi_from_name.emplace(poi[id].name, poi_id_vec);
        }

         poi_id_vec.clear();      
         poi_id_vec.shrink_to_fit(); 
        
        
    }
    //Get minimum and maximum position for features
    //Store feature data
    features.resize(getNumberOfFeatures());
    for(unsigned id=0;id<getNumberOfFeatures();++id){
        features[id].name=getFeatureName(id);
        features[id].type=getFeatureType(id);
        features[id].osm=getFeatureOSMID(id);
        
        unsigned i;
        for(i = 0; i < getFeaturePointCount(id); ++i){
            LatLon pos = getFeaturePoint(id, i);
                      
            features[id].position3.push_back(pos);
            
            
            featureRTree.insert(std::make_pair( 
                    RTreeLatLon(getFeaturePoint(id, i).lat(), 
                    getFeaturePoint(id, i).lon()), feature_id_rtree));
            feature_id_rtree++;
            
  
            maximum_latitude = std::max(maximum_latitude, 
                    pos.lat());
            maximum_longitude = std::max(maximum_longitude, 
                    pos.lon());
            minimum_latitude = std::min(minimum_latitude, 
                    pos.lat());
            minimum_longitude = std::min(minimum_longitude, 
                    pos.lon());
            
        }
        if(getFeaturePoint(id,0).lat()==getFeaturePoint(id,i-1).lat()&& 
              getFeaturePoint(id,0).lon()==getFeaturePoint(id,i-1).lon()  ){
            features[id].closed=true;
        }
        else
            features[id].closed=false;
        
        
        
        
    }
    
//   map_graph.all_intersections.resize(getNumberOfIntersections());
    
    //street segment
    streets.resize(getNumberOfStreetSegments());
    for(unsigned id = 0; id < getNumberOfStreetSegments(); ++id){
        
        auto ss_info = getStreetSegmentInfo(id);
        streets[id].printed = false;
        streets[id].oneway = ss_info.oneWay;
        streets[id].name = getStreetName(ss_info.streetID);
        streets[id].speed_limit = ss_info.speedLimit;
        streets[id].streetid = ss_info.streetID;
        
        if(id==0||maximum_speed<streets[id].speed_limit){
            maximum_speed=streets[id].speed_limit;
        }
        
        
        auto int_pos = getIntersectionPosition(ss_info.from);
        streets[id].position4.push_back(int_pos);
        
        auto ncurve = ss_info.curvePointCount;
        //For curve points
        if(ncurve > 0){             
            for(unsigned n = 0; n < ncurve; ++n){
                int_pos = getStreetSegmentCurvePoint(id, n);
                streets[id].position4.push_back(int_pos);
            }
        }
        //Add the last intersection
        int_pos = getIntersectionPosition(ss_info.to);

        streets[id].position4.push_back(int_pos);
        
        /////////////////////FIX///////////////////////////
//        //**********Graph****************
//        
//        
//        double travel_time = find_street_segment_travel_time(streets[id].streetid);
//      
//        unsigned position1 = ss_info.from;
//        
//        unsigned position2 = ss_info.to;
//          
//        
//        //Create the edges of the graph
//        Edges new_street_edge(id,travel_time,position1,position2); 
//        
//         
//        //Add all the vertex and edges to the graph
//        //For one way add the edge only from source to destination       
//        if(!streets[id].oneway){
//             //Add the edges pointing to both directions
//            new_street_edge.directed=false;
//            map_graph.addEdge(new_street_edge);
//            //Change destination to from and vice versa
//            new_street_edge.set_from(position2);
//            new_street_edge.set_to(position1);
//            map_graph.addEdge(new_street_edge);
//                  
//        }
//        else{
//            //Add only from to to
//            new_street_edge.directed=true;
//            map_graph.addEdge(new_street_edge);
//            
//        }
        
        
      
        
    }
    
    average_latitude = DEG_TO_RAD * (maximum_latitude + 
            minimum_latitude) * 0.5;
    
    maximum_speed=1000/3600*maximum_speed;
    
    load_angle();
}

void load_angle(){
    double angle;
        const double RIGHT_ANGLE = 90.0;
     for(unsigned id = 0; id < streets.size(); ++id){
         auto x1=longitude_to_cartesian(streets[id].position4[0].lon());
         auto x2=longitude_to_cartesian(streets[id].position4[1].lon());
         
         auto y1=latitude_to_cartesian(streets[id].position4[0].lat());
         auto y2=latitude_to_cartesian(streets[id].position4[1].lat());
         
        auto delta_y = y2 - y1;
        auto delta_x = x2 - x1;
        
        if (delta_x != 0){
            angle = atan(delta_y / delta_x) / DEG_TO_RAD;
        }
        else {
            angle = RIGHT_ANGLE;
        }
        
        streets[id].angle = angle;
     }
}



//Returns the point of interest id from name
std::vector<unsigned> find_poi_from_name(std::string poi_name) {
//If the poi name is not found returns an empty vector
    if(poi_from_name.find(poi_name) == poi_from_name.end())
        return {};
        
    return poi_from_name[poi_name];
    
}

//Return poi data from poi ids
poi_data get_poi_data(unsigned poi_id){
    return poi[poi_id];
}

